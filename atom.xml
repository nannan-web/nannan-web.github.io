<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://github.com/nannan-web</id>
    <title>nannan</title>
    <updated>2020-06-24T08:00:00.166Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://github.com/nannan-web"/>
    <link rel="self" href="https://github.com/nannan-web/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://github.com/nannan-web/images/avatar.png</logo>
    <icon>https://github.com/nannan-web/favicon.ico</icon>
    <rights>All rights reserved 2020, nannan</rights>
    <entry>
        <title type="html"><![CDATA[笔记-01-String 是如何实现的？它有哪些重要的方法？]]></title>
        <id>https://github.com/nannan-web/post/bi-ji-01-string-shi-ru-he-shi-xian-de-ta-you-na-xie-chong-yao-de-fang-fa/</id>
        <link href="https://github.com/nannan-web/post/bi-ji-01-string-shi-ru-he-shi-xian-de-ta-you-na-xie-chong-yao-de-fang-fa/">
        </link>
        <updated>2020-06-21T11:19:38.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>以主流的 JDK 版本 1.8 来说，String 内部实际存储结构为 char 数组，源码如下：<br>
public final class String<br>
    implements java.io.Serializable, Comparable<String>, CharSequence {<br>
    // 用于存储字符串的值<br>
    private final char value[];<br>
    // 缓存字符串的 hash code<br>
    private int hash; // Default to 0<br>
    // ......其他内容<br>
}</p>
<p>String 源码中包含下面几个重要的方法。</p>
<ol>
<li>多构造方法<br>
String 字符串有以下 4 个重要的构造方法：</li>
</ol>
<p>// String 为参数的构造方法<br>
public String(String original) {<br>
    this.value = original.value;<br>
    this.hash = original.hash;<br>
}<br>
// char[] 为参数构造方法<br>
public String(char value[]) {<br>
    this.value = Arrays.copyOf(value, value.length);<br>
}<br>
// StringBuffer 为参数的构造方法<br>
public String(StringBuffer buffer) {<br>
    synchronized(buffer) {<br>
        this.value = Arrays.copyOf(buffer.getValue(), buffer.length());<br>
    }<br>
}<br>
// StringBuilder 为参数的构造方法<br>
public String(StringBuilder builder) {<br>
    this.value = Arrays.copyOf(builder.getValue(), builder.length());<br>
}<br>
其中，比较容易被我们忽略的是以 StringBuffer 和 StringBuilder 为参数的构造函数，因为这三种数据类型，我们通常都是单独使用的，所以这个小细节我们需要特别留意一下。</p>
<ol start="2">
<li>equals() 比较两个字符串是否相等<br>
源码如下：</li>
</ol>
<p>public boolean equals(Object anObject) {<br>
    // 对象引用相同直接返回 true<br>
    if (this == anObject) {<br>
        return true;<br>
    }<br>
    // 判断需要对比的值是否为 String 类型，如果不是则直接返回 false<br>
    if (anObject instanceof String) {<br>
        String anotherString = (String)anObject;<br>
        int n = value.length;<br>
        if (n == anotherString.value.length) {<br>
            // 把两个字符串都转换为 char 数组对比<br>
            char v1[] = value;<br>
            char v2[] = anotherString.value;<br>
            int i = 0;<br>
            // 循环比对两个字符串的每一个字符<br>
            while (n-- != 0) {<br>
                // 如果其中有一个字符不相等就 true false，否则继续对比<br>
                if (v1[i] != v2[i])<br>
                    return false;<br>
                i++;<br>
            }<br>
            return true;<br>
        }<br>
    }<br>
    return false;<br>
}<br>
String 类型重写了 Object 中的 equals() 方法，equals() 方法需要传递一个 Object 类型的参数值，在比较时会先通过 instanceof 判断是否为 String 类型，如果不是则会直接返回 false，instanceof 的使用如下：</p>
<p>Object oString = &quot;123&quot;;<br>
Object oInt = 123;<br>
System.out.println(oString instanceof String); // 返回 true<br>
System.out.println(oInt instanceof String); // 返回 false<br>
当判断参数为 String 类型之后，会循环对比两个字符串中的每一个字符，当所有字符都相等时返回 true，否则则返回 false。</p>
<p>还有一个和 equals() 比较类似的方法 equalsIgnoreCase()，它是用于忽略字符串的大小写之后进行字符串对比。</p>
<ol>
<li>compareTo() 比较两个字符串<br>
compareTo() 方法用于比较两个字符串，返回的结果为 int 类型的值，源码如下：</li>
</ol>
<p>public int compareTo(String anotherString) {<br>
    int len1 = value.length;<br>
    int len2 = anotherString.value.length;<br>
    // 获取到两个字符串长度最短的那个 int 值<br>
    int lim = Math.min(len1, len2);<br>
    char v1[] = value;<br>
    char v2[] = anotherString.value;<br>
    int k = 0;<br>
    // 对比每一个字符<br>
    while (k &lt; lim) {<br>
        char c1 = v1[k];<br>
        char c2 = v2[k];<br>
        if (c1 != c2) {<br>
            // 有字符不相等就返回差值<br>
            return c1 - c2;<br>
        }<br>
        k++;<br>
    }<br>
    return len1 - len2;<br>
}<br>
从源码中可以看出，compareTo() 方法会循环对比所有的字符，当两个字符串中有任意一个字符不相同时，则 return char1-char2。比如，两个字符串分别存储的是 1 和 2，返回的值是 -1；如果存储的是 1 和 1，则返回的值是 0 ，如果存储的是 2 和 1，则返回的值是 1。</p>
<p>还有一个和 compareTo() 比较类似的方法 compareToIgnoreCase()，用于忽略大小写后比较两个字符串。</p>
<p>可以看出 compareTo() 方法和 equals() 方法都是用于比较两个字符串的，但它们有两点不同：</p>
<p>equals() 可以接收一个 Object 类型的参数，而 compareTo() 只能接收一个 String 类型的参数；<br>
equals() 返回值为 Boolean，而 compareTo() 的返回值则为 int。<br>
它们都可以用于两个字符串的比较，当 equals() 方法返回 true 时，或者是 compareTo() 方法返回 0 时，则表示两个字符串完全相同。</p>
<p>4. 其他重要方法<br>
indexOf()：查询字符串首次出现的下标位置<br>
lastIndexOf()：查询字符串最后出现的下标位置<br>
contains()：查询字符串中是否包含另一个字符串<br>
toLowerCase()：把字符串全部转换成小写<br>
toUpperCase()：把字符串全部转换成大写<br>
length()：查询字符串的长度<br>
trim()：去掉字符串首尾空格<br>
replace()：替换字符串中的某些字符<br>
split()：把字符串分割并返回字符串数组<br>
join()：把字符串数组转为字符串</p>
<p>为什么 String 类型要用 final 修饰？<br>
== 和 equals 的区别是什么？<br>
String 和 StringBuilder、StringBuffer 有什么区别？<br>
String 的 intern() 方法有什么含义？<br>
String 类型在 JVM（Java 虚拟机）中是如何存储的？编译器对 String 做了哪些优化？<br>
接下来我们一起来看这些问题的答案。</p>
<p>知识扩展<br>
1. == 和 equals 的区别<br>
== 对于基本数据类型来说，是用于比较 “值”是否相等的；而对于引用类型来说，是用于比较引用地址是否相同的。</p>
<p>查看源码我们可以知道 Object 中也有 equals()  方法，源码如下：</p>
<p>public boolean equals(Object obj) {<br>
    return (this == obj);<br>
}<br>
可以看出，Object 中的 equals() 方法其实就是 ==，而 String 重写了 equals() 方法把它修改成比较两个字符串的值是否相等。</p>
<p>源码如下：</p>
<p>public boolean equals(Object anObject) {<br>
    // 对象引用相同直接返回 true<br>
    if (this == anObject) {<br>
        return true;<br>
    }<br>
    // 判断需要对比的值是否为 String 类型，如果不是则直接返回 false<br>
    if (anObject instanceof String) {<br>
        String anotherString = (String)anObject;<br>
        int n = value.length;<br>
        if (n == anotherString.value.length) {<br>
            // 把两个字符串都转换为 char 数组对比<br>
            char v1[] = value;<br>
            char v2[] = anotherString.value;<br>
            int i = 0;<br>
            // 循环比对两个字符串的每一个字符<br>
            while (n-- != 0) {<br>
                // 如果其中有一个字符不相等就 true false，否则继续对比<br>
                if (v1[i] != v2[i])<br>
                    return false;<br>
                i++;<br>
            }<br>
            return true;<br>
        }<br>
    }<br>
    return false;<br>
}<br>
2. final 修饰的好处<br>
从 String 类的源码我们可以看出 String 是被 final 修饰的不可继承类，源码如下：</p>
<p>public final class String <br>
implements java.io.Serializable, Comparable<String>, CharSequence { //...... }<br>
那这样设计有什么好处呢？</p>
<p>Java 语言之父 James Gosling 的回答是，他会更倾向于使用 final，因为它能够缓存结果，当你在传参时不需要考虑谁会修改它的值；如果是可变类的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上就会有一定的损失。</p>
<p>James Gosling 还说迫使 String 类设计成不可变的另一个原因是安全，当你在调用其他方法时，比如调用一些系统级操作指令之前，可能会有一系列校验，如果是可变类的话，可能在你校验过后，它的内部的值又被改变了，这样有可能会引起严重的系统崩溃问题，这是迫使 String 类设计成不可变类的一个重要原因。</p>
<p>总结来说，使用 final 修饰的第一个好处是安全；第二个好处是高效，以 JVM 中的字符串常量池来举例，如下两个变量：</p>
<p>String s1 = &quot;java&quot;;<br>
String s2 = &quot;java&quot;;<br>
只有字符串是不可变时，我们才能实现字符串常量池，字符串常量池可以为我们缓存字符串，提高程序的运行效率，如下图所示：</p>
<p>试想一下如果 String 是可变的，那当 s1 的值修改之后，s2 的值也跟着改变了，这样就和我们预期的结果不相符了，因此也就没有办法实现字符串常量池的功能了。</p>
<p>3. String 和 StringBuilder、StringBuffer 的区别<br>
因为 String 类型是不可变的，所以在字符串拼接的时候如果使用 String 的话性能会很低，因此我们就需要使用另一个数据类型 StringBuffer，它提供了 append 和 insert 方法可用于字符串的拼接，它使用 synchronized 来保证线程安全，如下源码所示：</p>
<p>@Override<br>
public synchronized StringBuffer append(Object obj) {<br>
    toStringCache = null;<br>
    super.append(String.valueOf(obj));<br>
    return this;<br>
}</p>
<p>@Override<br>
public synchronized StringBuffer append(String str) {<br>
    toStringCache = null;<br>
    super.append(str);<br>
    return this;<br>
}<br>
因为它使用了 synchronized 来保证线程安全，所以性能不是很高，于是在 JDK 1.5 就有了 StringBuilder，它同样提供了 append 和 insert 的拼接方法，但它没有使用 synchronized 来修饰，因此在性能上要优于 StringBuffer，所以在非并发操作的环境下可使用 StringBuilder 来进行字符串拼接。</p>
<p>4. String 和 JVM<br>
String 常见的创建方式有两种，new String() 的方式和直接赋值的方式，直接赋值的方式会先去字符串常量池中查找是否已经有此值，如果有则把引用地址直接指向此值，否则会先在常量池中创建，然后再把引用指向此值；而 new String() 的方式一定会先在堆上创建一个字符串对象，然后再去常量池中查询此字符串的值是否已经存在，如果不存在会先在常量池中创建此字符串，然后把引用的值指向此字符串，如下代码所示：</p>
<p>String s1 = new String(&quot;Java&quot;);<br>
String s2 = s1.intern();<br>
String s3 = &quot;Java&quot;;<br>
System.out.println(s1 == s2); // false<br>
System.out.println(s2 == s3); // true<br>
它们在 JVM 存储的位置，如下图所示：</p>
<p>小贴士：JDK 1.7 之后把永生代换成的元空间，把字符串常量池从方法区移到了 Java 堆上。</p>
<p>除此之外编译器还会对 String 字符串做一些优化，例如以下代码：</p>
<p>String s1 = &quot;Ja&quot; + &quot;va&quot;;<br>
String s2 = &quot;Java&quot;;<br>
System.out.println(s1 == s2);<br>
虽然 s1 拼接了多个字符串，但对比的结果却是 true，我们使用反编译工具，看到的结果如下：</p>
<p>Compiled from &quot;StringExample.java&quot;<br>
public class com.lagou.interview.StringExample {<br>
  public com.lagou.interview.StringExample();<br>
    Code:<br>
       0: aload_0<br>
       1: invokespecial #1                  // Method java/lang/Object.&quot;<init>&quot;😦)V<br>
       4: return<br>
    LineNumberTable:<br>
      line 3: 0</p>
<p>public static void main(java.lang.String[]);<br>
    Code:<br>
       0: ldc           #2                  // String Java<br>
       2: astore_1<br>
       3: ldc           #2                  // String Java<br>
       5: astore_2<br>
       6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>
       9: aload_1<br>
      10: aload_2<br>
      11: if_acmpne     18<br>
      14: iconst_1<br>
      15: goto          19<br>
      18: iconst_0<br>
      19: invokevirtual #4                  // Method java/io/PrintStream.println:(Z)V<br>
      22: return<br>
    LineNumberTable:<br>
      line 5: 0<br>
      line 6: 3<br>
      line 7: 6<br>
      line 8: 22<br>
}<br>
从编译代码 #2 可以看出，代码 &quot;Ja&quot;+&quot;va&quot; 被直接编译成了 &quot;Java&quot; ，因此 s1==s2 的结果才是 true，这就是编译器对字符串优化的结果。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://github.com/nannan-web/post/hello-gridea/</id>
        <link href="https://github.com/nannan-web/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>